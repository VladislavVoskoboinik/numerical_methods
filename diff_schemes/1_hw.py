# Решение краевой задачи для обыкновенного дифференциального уравнения:

#       u''(x) = - f(x), x \in (0,1),
#       u'(0) = g_0,   u(1)=g_1.
#--------------------------------------------------------------------------

# Решение задачи 5.2
import numpy as np
import matplotlib.pyplot as plt
import math


def progonka(A,B,C,F,kappa,mu,N):
    Y=[0]*(N+1) 
    alpha=[0]*N
    beta=[0]*N
    alpha[0]=kappa[0];
    beta[0]=mu[0];
 
# прямой ход прогонки:
    n=1
    while n<=N-1:
        alpha[n]=B/(C-A*alpha[n-1])
        beta[n]=(A*beta[n-1]+F[n])/(C-A*alpha[n-1])
        n+=1
 
# обратный ход прогонки:
    Y[N]=(mu[1]+kappa[1]*beta[N-1])/(1-kappa[1]*alpha[N-1])
    n=N-1
    while n>=0:
        Y[n]=alpha[n]*Y[n+1]+beta[n]
        n=n-1
    return Y

#-----------------------------------------------------------------------
# Решение задачи 5.2

# коэффициенты в системе с трехдиагональной матрицей:
# A*y_{n-1} - C*y_{n} + B*y_{n+1} = -F_{n},  n=2,3,...,N-1;
# y_{1} = kappa(1)*y_{2} + mu(1);
# y_{N} = kappa(2)*y_{N-1} + mu(2).

A = 1
B = 1
C = 2
kappa=[1, 0]

N=31            # число точек сетки
#p=3.1415926535  # число пи
p=np.pi
h=1/N           # шаг сетки
F=[0]*(N+1)     # правая часть уравнения 
u=[0]*(N+1)     # аналитическое решение
x=[0]*(N+1)     # массив x 
n=0
while n<=N:
    x[n]=n*h
    F[n]=h**2*(x[n]+1)
    u[n]=-(x[n]**3)/6 - (x[n]**2)/2 + 2.5*x[n]+1.25
    n+=1



cond=2 # Выбор варианта аппроксимации граничного условия 

# 1) Простейшее граничное условие с первым порядком аппроксимации:
if cond==1:
    kappa=[1/(1+2*h), 1]
    mu=[0, h] 

# 2) Модифицированное граничное условие, обеспечивающее второй порядок
#    погрешности аппроксимации:
if cond==2:
    mu=[0, h+(h**2)/2]
    kappa=[1/(1+2*h), 1]

# 3) Использование односторонней трехточечной производной для достижения 
# второго порядка погрешности:
if cond==3:
    mu=[-h+(h**2)*math.cos(p*h)/2, -1/(p**2)]

# Решение системы методом прогонки:
Y = progonka(A,B,C,F,kappa,mu,N)



# Построение графиков точного и приближенного решения
fig,ax = plt.subplots()
plt.plot(x, u)
plt.scatter(x, Y, color='red')
ax.set_xlabel('x')
ax.set_ylabel('u')
ax.set_title('Точное и приближенное решение')
plt.legend(['точное решение','приближенное решение'])
plt.show()

# Вычисление погрешности на сгущающихся сетках-----------------------------
NN=10          # число сеток, на которых решаем задачу (для построения
               # зависимости погрешности от шага сетки)
N=[0]*NN       # число точек на отрезке [0,1], соответствующее фиксированному
               # разбиению
N[0]=30        # начальное число точек

# сгущаем сетки так, чтобы для каждой новой шаг был в два раза меньше, 
# чем на предыдущей
j=1
while j<NN:
    N[j]=2*N[j-1]
    j+=1
      
h=[0]*NN        # шаги сетки
norm_err=[0]*NN # нормы погрешностей схемы

j=0
while j<NN:
    h[j]=1/N[j]      # шаг сетки
    F=[0]*(N[j]+1)   # правая часть уравнения 
    u=[0]*(N[j]+1)   # аналитическое решение
    x=[0]*(N[j]+1)   # массив x (на сетке с текущим номером j)
    n=0
    while n<=N[j]:
        x[n]=n*h[j]
        F[n]=h[j]**2*(x[n]+1)
        u[n]=-(x[n]**3)/6 - (x[n]**2)/2 + 2.5*x[n]+1.25
        n+=1
    
    # 1) Простейшее граничное условие с первым порядком аппроксимации:
    if cond==1:
        kappa=[1/(1+2*h[j]), 1]
        mu=[0, h[j]] 

    # 2) Модифицированное граничное условие, обеспечивающее второй порядок
    #    погрешности аппроксимации:
    if cond==2:
        mu=[0, h[j]+(h[j]**2)/2]
        kappa=[1/(1+2*h[j]), 1]

    # 3) Использование односторонней трехточечной производной для достижения 
    # второго порядка погрешности:
    if cond==3:
        mu=[-h[j]+(h[j]**2)*math.cos(p*h[j])/2, -1/(p**2)]
       
    # Решение системы методом прогонки:
    Y = progonka(A,B,C,F,kappa,mu,N[j])
 
    # Вычисление нормы погрешности:
    s=((u[0]-Y[0])**2)*h[j]/2
    n=1
    while n<=N[j]-1:
        s=s+((u[n]-Y[n])**2)*h[j]
        n+=1
    
    s=s+((u[N[j]]-Y[N[j]])**2)*h[j]/2
    norm_err[j]=math.sqrt(s)
    j+=1

#--------------------------------------------------------------------------

# Построение графиков точного и приближенного решения
fig,ax = plt.subplots()
plt.plot(h, norm_err)
plt.scatter(h, norm_err, color='red')
ax.set_xlabel('шаг h')
ax.set_ylabel('норма погрешности')
ax.set_title('Погрешность')
plt.show()